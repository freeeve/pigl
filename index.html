<!DOCTYPE html>
<html lang="en">
  <head>
    <title>monte carlo pi</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        color: #ffffff;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
      }
      #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
        font-family: Monospace;
        font-size: 15px;
        text-align: center;
      }
    </style>
  </head>

  <body>
    <div id="container"></div>
    <div id="info">monte carlo pi calculation in webgl by Eve <br/>
      pi: <span id="pi"></span>, spherePoints: <span id="sphere"></span>, cubePoints: <span id="cube"></span><br/>
      pi = 6 * spherePoints / cubePoints
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/84/three.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.1.1.min.js"></script>

    <script>
var RADIUS = 100;
var MAX_PARTICLES = 1000000;
var COUNT_PER_LOOP = 100;
var THETA_INCREMENT = 0.02;
var CAMERA_MULTIPLIER = 4.25;
var renderer, scene, camera;

var raycaster, intersects;
var mouse, INTERSECTED;

var sphereCount = 0;
var cubeCount = 0;
var totalCount = 0;

var sphereGeometry = new THREE.BufferGeometry();
var spherePositions = new Float32Array( MAX_PARTICLES * 3 );

var cubeGeometry = new THREE.BufferGeometry();
var cubePositions = new Float32Array( MAX_PARTICLES/2 * 3 );

var purple = new THREE.Color( 0xff00ff );
var green = new THREE.Color( 0x00ff00 );
var cubeMaterial = new THREE.PointsMaterial({color:green, transparent: true, opacity: 0.35});
var sphereMaterial = new THREE.PointsMaterial({color:purple, transparent: true, opacity: 0.5});

init();
animate();

function addNewPoint() {
  var x = ( Math.random() * 2 - 1 ) * RADIUS;
  var y = ( Math.random() * 2 - 1 ) * RADIUS;
  var z = ( Math.random() * 2 - 1 ) * RADIUS;

  if(Math.sqrt(x * x + y * y + z * z) <= RADIUS) {
    var i3 = sphereCount * 3;
    spherePositions[ i3 + 0 ] = x;
    spherePositions[ i3 + 1 ] = y;
    spherePositions[ i3 + 2 ] = z;
    sphereCount++;
  } else {
    var i3 = cubeCount * 3;
    cubePositions[ i3 + 0 ] = x;
    cubePositions[ i3 + 1 ] = y;
    cubePositions[ i3 + 2 ] = z;
    cubeCount++;
  }

  sphereGeometry.setDrawRange(0, sphereCount);
  cubeGeometry.setDrawRange(0, cubeCount);

  totalCount++;
}

function init() {
  container = document.getElementById( 'container' );
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
  camera.position.z = RADIUS * 2.5;

  for(var i = 0; i < COUNT_PER_LOOP; i++) {
    addNewPoint();
  }

  sphereGeometry.addAttribute( 'position', new THREE.BufferAttribute( spherePositions, 3 ) );
  cubeGeometry.addAttribute( 'position', new THREE.BufferAttribute( cubePositions, 3 ) );

  spherePoints = new THREE.Points( sphereGeometry, sphereMaterial );
  cubePoints = new THREE.Points( cubeGeometry, cubeMaterial );
  scene.add( spherePoints );
  scene.add( cubePoints );

  renderer = new THREE.WebGLRenderer();
  renderer.setPixelRatio( window.devicePixelRatio );
  renderer.setSize( window.innerWidth, window.innerHeight );
  container.appendChild( renderer.domElement );

  raycaster = new THREE.Raycaster();
  mouse = new THREE.Vector2();

  window.addEventListener( 'resize', onWindowResize, false );
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}

function animate() {
  if(sphereCount < MAX_PARTICLES) {
    requestAnimationFrame( animate );
  }
  render();
}

var theta = 0;

function render() {

  theta += THETA_INCREMENT;
  var radius = RADIUS * CAMERA_MULTIPLIER;
  camera.position.x = radius * Math.sin( THREE.Math.degToRad( theta ) );
  camera.position.y = radius * Math.sin( THREE.Math.degToRad( theta ) );
  camera.position.z = radius * Math.cos( THREE.Math.degToRad( theta ) );
  camera.lookAt( scene.position );
  camera.updateMatrixWorld();

  for(var i = 0; i < COUNT_PER_LOOP; i++) {
    addNewPoint();
  }

  sphereGeometry.attributes.position.needsUpdate = true;
  cubeGeometry.attributes.position.needsUpdate = true;

  updatePi(sphereCount, totalCount);
  
  renderer.render( scene, camera );
}

function updatePi(sphere, cube) {
  $('#sphere').text(sphere);
  $('#cube').text(cube);
  $('#pi').text((6 * sphere / cube).toFixed(10));
}
    </script>
  </body>
</html>
